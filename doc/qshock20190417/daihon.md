
# 具体的な議論

## 現在、個人(会社でも？)で取り組んでいるソフトウェアの品質向上への取り組み概要

* 品質とは、顧客の明示的・暗黙的期待にどれだけ応えているか
    * 品質 ≒ ((生産性 * 時間) \cup 期待) / 期待 でざっくり近似して考えてる

* そのソフトウェアを手段としてどんな課題を解決すべきか、何故解決したいのかを知り、まずはそれに一番効果を発揮するMVPを目指す
    * 相手の考えや意見(〜が欲しい)だけでなく、相手の状況を知ること(具体的な業務フローとか、目標数値とか、〜のせいで・・出来なくて困っているとか)
    * 捨てられるものは捨てて重要なものから手をつける
    * スクラム的なアプローチを取り、早く作って早く評価する

* 失敗談を[ここ](SoftwareQuality.md)に色々書いた

* 個人的に情報の整理や推敲の為にモデルを書いている
    * 詳しい動機とかは[ここ](../spec20180810/memo.md) に書いた
    * ただ、最近は性格的にキチッとしていて頭の中にZ3ソルバ詰んでる人ならわざわざモデルなんて書かなくても正しい判断をするような気がする（私は出来ない)

## (ハードウェアスタートアップとしての)理想的な受託開発フロー

* 理想というか、生産性(達成品質/時間)という観点でスクラムのようなアプローチは割といい線いってるとは思う(早く作って早く評価する)

* 受託でスクラムやる上で問題になっている点
    * 不確実性や工数の都合もあって十分な分析・検討が受注の前に出来ず、見積りがブレる
    * マンリソースが少ないとどうしてもマルチプロジェクトにならざるを得ない(コンテキストスイッチのコストとコミュニケーションコストがヤバイ。スケジュールも見失いやすく、バックログも腐りやすくなる)
    * 調達や外注製造のリスク顕在化（品質やレイテンシ）


---

* 品質確保しようと思うと十分な時間が必要。特に品質評価は早い段階から何回も行えるだけの時間を確保したい(まぁ実際にはそう上手く行かないことが多いが)
    * メカ・電気については３回以上は作ってみないと収束しない傾向があるように見える
    * HW開発でスクラムやるんだったら社内に製造設備・実験場は必須だなとは思う

* SW屋から見てHWが辛い点は沢山ある
    * モノは移動、コピー、製造に時間と金と失敗リスクが発生する(失敗のコストが大きく、見積もりのブレも大きくなる)
        * 試作 -> フィードバックのループを回すのに時間がかかる(機械学習とかでもそうだけど) => お金を使って投機実行したり・・・
        * 作って現地で動かさないと分からないことが沢山ある
    * モノがよく劣化したり、変化したり、壊れたりする
    * モノは物理法則や空間的な制約によってモジュール間に依存関係が発生する
    * モノがないと開発者は作業出来ない場合が多い（リモートワークし辛い)
    * メカ・電気・ソフトの問題切り分けが大変、個体差とかもある
    * 開発部屋がうるさい、モノが溢れる、モノがなくなる、オフィスが手狭になる（コストフル）
    * モノを探す時間が増す（いつのまにか移動したり捨てられたり）
    * 現場環境が過酷な時もある(暑いとかトイレないとかネット回線ないとか)
    * 特許や規格の問題
    * 理論計算と現実のギャップ

---

## CSP検査ツールを自作した話

* FDR買えば良かった(金で解決出来る問題は金で解決すべきだ)

## TLA+を組み込み開発で運用してみた話

* 話題になってたTLA+触ってみたかった
* ブラックボックスなアプリのモデルを記述するのに使った
* 使ってみた感想
    * 状態遷移を論理式で表していく
    * 直感的かつ使いやすい
    * 動的型付辛い＆ツールの吐くエラーに行番号ない時発狂する＆集合の要素数の上限低すぎ..
* 他のモデル検査とTLA+の比較は[ここ](../spec20180810/memo.md) に書いた


## UMLモデリングと形式的なモデリングの違い

* UML/SysMLの状態遷移図やユースケース図といったものを形式的なモデルを使って表現しようとしてきた
* UML/SysMLの図は誰でも読めてなんとなく書けるという点で扱いやすく、自然言語よりもイメージを伝えやすい一方、パラメトリックな表現が難しく、ページや画面の制約を受ける(表現力が乏しい)
* 形式的に記述すると誰でも読めないし、書いてある情報からイメージに変換するのにコストがかかるし、見落としもしやすい。しかし表現力は高く、検査も出来る。


## 定理証明と形式的なモデリングの違い

* 定理証明の定義よく知らない
* モデル作って振る舞いの表明するところまでは同じでは？
* 証明用の言語とか型システムやアノテーション使って証明するのが定理証明のイメージ

## そもそも形式的なモデル/テスト/定理証明などの異なる手法によって削減できる不具合は異なるのか

* 異なると思う。加えて不具合の種別ってフェーズで区切ることが多いが、こういった不具合をいつ検出出来るが重要。
* モデルを仕様に使えば、要求の問題をその段階で検出出来る期待してる。実装の問題はテストなり定理証明なりで実装中または後に検出することになると思う。
* あとテスト作る為にモデルはあった方が良い


## TLA+の検査時間をz3などの外部ソルバで短縮できる？

* ごめんなさい。正直分からないです。プロファイルとってみないと何故遅いか分からないし、z3がそれを解決するかもさっぱり分からない。
* ただの推測だけど、状態爆発して馬鹿でかいファイル吐きまくってる現状を鑑みると、そういった爆発を抑えこむ工夫がz3にあるならマシにはなるのでは？
* ちなみに今はそんなに時間かけずに検査してます
    * イベントの種類や状態の数が大きくなると遷移回数5を確保することすら難しくなるので不安は残る(テストケースの最大イベント数である50程度の深さは欲しい)
    * 初期状態を増やすことで誤魔化してる


## 某L社での形式手法との比較

* 当時のツールは検査が出来なかったのでレビューで正しさを担保していた。
    * コレがボクにはキツかった。並行合成人間には無理
    * 当時の尊敬するBOSSは頭の中にZ3ソルバ持ってて普通にチェックしてた
    * 最近そのツールが進化して検査も出来るようになったらしい。スゴイ・・・
* QAチームや慣れない開発者のことを考慮してた
    * 記述は日本語併記(QAチームでもエンジニア指向の人達は普通に日本語読まなくなって式追ってたのにビックリしたが)
    * DRYよりDAMP優先だった(私はDRY派)

## 納品時にお客様が「成果物が想定と違う」と主張された時に我々は何ができるのか

過去に戻ることは出来ない。原因を振り返って、次のゴールを決めて合意するしかない。

## 段階的詳細化をして、実装に近いモデルを得ることは実際のビジネスでは機能するのか

* 近いの度合いによるけど、非同期系のバグ潰す為にモジュール設計の妥当性担保くらいは実例あるので機能すると思う
* ただ、ブラックボックスのライブラリやハードの振る舞いを直接モデル化するのは辛そう(メーカーやライブラリ製作者がモデル用意してくれたらいいのに)


## そもそも元のモデルの筋が悪ければ、段階的詳細化をしても筋の良い詳細なモデルは得られないのでは

筋の良し悪しとはなんだろう？美しい設計や実装と同じようなニュアンス？

## 筋の良いモデルであれば、抽象度の高いモデルのまま加工すれば良いのでは

加工とは？何が得られる？

## 最適化されたアルゴリズムが元のアルゴリズムの仕様を違反していないか主張する良い方法

* 正直な所、分からない
    * これが欲しくて定理証明とか勉強しはじめた覚えがある
    * プログラム単位なんだったら最適化はコンパイラが勝手にやってくれというのが正直な気持ち
    * 等価性の研究とかチラ見したけど、ふ〜んで終わった覚えがある。bisimulationとか。
* 思いつく範囲で
    * よくやるのが網羅テストで結果の一致度合いをみる
    * Isabelleとかで振るまい一致をチェックする(手続き言語用のもあったハズ)
    * 元のアルゴリズムの入出力の関係が表現出来るなら依存型使った定理証明とか
    * 数式ならmathmaticaとかでいいのでは(まぁ実際の所、1bitもずらすなとか言われる場合があって辛かったりするけど)
    * アルゴリズムというのがアクセラレーターの振る舞いを含んだりすると途端に大変になりそうだけど・・・

## 定理証明の先に未来はあるのか

ど素人だけど、論理学や計算論というものが終わりを迎えるとは到底思えない。
反例探索の効率化とか証明の自動化の進化については、よく分からない。


## 形式的なモデルは何時までメンテナンスし続けるべきか

プロジェクトが終了するまで

## 読書時間の確保の方法とその集中のためにどんな手法が使えるのか

通勤時間

## 家事育児の中での研究開発時間の確保方法

研究開発は仕事でやるべき・・・

## おすすめ書籍紹介

誰向けかにもよるけれど、一番お世話になってる本はソフトウェア要求。面白かった本はプログラミングの科学。


## 一言

* モデル書くのはゲーム作ってるみたいで楽しい。

