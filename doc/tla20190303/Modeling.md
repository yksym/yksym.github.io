TLA+を使ったモデリングとテストについてのメモ
============

某プロジェクトでGUIアプリケーションを作っててその時にTLA+を使ってみたので、その時のメモ。


背景とか目的とか
-----------

* 今回は、このシステムのテストどう作るねん、そもそも絶賛実装中のシステムの仕様どうなってんねん、という話からスタートした
* QA経験も特にないマンが(ブラックボックス的に)バグ見つかりそうなテストケースを用意せないかんかったし、しかもテストケースの件数の妥当性とか説明せないかんかった ->  そんなん形式的にやるしかないやろ(？)
* TLA+である理由: 関係者に説明しやすい（UMLの状態遷移図とか誰もが読み書きした経験ある）
* 形式的に仕様書く目的は[前書いた通り](../spec20180810/memo.md)


TLA+
--------

* TLA+で扱うモデルは状態マシン
* 変数を用意し、その変数の束縛状態でシステムの状態を表現
* TLA+ではイベントのことをアクションと呼んでる
* アクションは、論理式で記述され、事前条件(ガード条件)と事後条件を記述する


モデルの抽象度
---------------

現実の詳細をどこまで削ぎ落とすべきかについての詳細は、それぞれ以下の状態とアクションについて書くけど、大体以下の通り

* エンドユーザーから見たシステムの振る舞いのみに絞ってなるべく簡潔に記述する(外部のサービスとどう連携するかとかは記述しない)
* ルック&フィールについては極力モデルではなくコメントで記述するだけに留める(プログレスバーの振る舞いとかはわざわざ書かなかった)
* 誤差とか成功確率といった精度については非決定性を使って表現する
* データ網羅性は諦める(小スコープ仮説)



状態
-----------

モデリングの際、変数を3種類に分けて扱っていた。

* システムの状態のうち、目に見えるもの
    * 例えば通電状態とか、システム時刻、表示項目とか、ボタンのenable/disableとか。要求仕様やテスト手順で出てきそうな名詞は少なくとも入れた
    * 画面変数を用意し、１画面を1つのレコードで表現した。画面変数の型を表現するのに直和型っぽいものを[こんな感じで](https://github.com/yksym/tla_sumtype/blob/master/SumType.tla)用意した
* システムの状態のうち、目に見えないが、制御には必要なもの
    * 例えば何かしらのフラグとか永続化情報とかいったもの
    * 他の変数の組み合わせと等価な変数であっても用意しておくと便利な場合があった。例えば、システムの状態をXX状態、YY状態といったものにMECEに分割すると、イベントのガード条件が書きやすく、チェックもしやすい(勿論、これに対する不変条件を書いておいてチェックする必要もあるけど)
* アクション履歴
    * 探索の深さを制限したり、アクション列を明示的に指定したりするのに使った
    * 探索の深さを制限は、-depthオプション少し試して意図した振る舞いにならなかった
    * TLA+にはX(Next演算子)がなく、時相論理でアクション列を明示的に指定する方法が分からなかった

また、変数が取りうる値の範囲もそのまま検査に使うと状態爆発する。そこで基本はAlloyの小スコープ仮説にならって、解像度も範囲も小さくしてほとんどの集合の要素数は3〜5程度にした。
ただし、閾値とかの定数が仕様として記述が必要だったりするので、そういうのは定数を使ってコメントで本来の値を書いて、検査時に都合の良い値を設定するようにした。

アクション
------------

アクションも2種類に分けて扱った。

* 割り込みイベント
    * 例えば、ボタンを押すといったユーザーの操作、デバイスや他のマシン・プロセスからのプッシュ通知、突然発生するエラーとかそういうの
    * 基本的にはatomicだと見做せるような極短期間に開始・終了するイベントである必要がある
* 時間経過イベント
    * 都合の良いように離散化した(⊿T秒毎にシステムが状態を更新するようなモデル)
    * 時間経過イベントはたった1つ用意するだけでも記述可能なのだが、そうすると非常に複雑な論理式の記述になってしまう。そこでガード条件をMECEに分けて別アクションとして分割した。
    * こうすることで、重複記述は増すけれど、見通しもよく、後述するテストケース記述においても可読性が上がった
    * ガード条件の設定方法は、意味的に分かりやすく、かつ1つのイベントで許容出来るIFの数が多すぎないように心がけた


時相論理を使った制約や検証
-----------------------

不変条件(Safety)しか記述しなかった。


書いたモデルが正しいかの確認
------------------------------

やったことは4つ。

* 機能要求、業務シナリオ、ユースケースとかいったものを作ったモデルのアクションの列で記述して、正しく受理されるか、そして状態が意図した通りに変化するることを確認する
* 無効なアクションの列が受理されないことを確認する
* 網羅探索させて不変条件が破られていないことを確認する
    * ちなみに初期状態は1つに限定した
* 上3つを行って得られるカバレッジを見てデッドコードがないことを確認する

最初2つの実現方法は後述する。あとこれらの為に記述したアクション列はそのまま実装用のテストの手順としてそのまま使った。


### モデルのテスト方法

* 全てのパスに対してパス論理式が満たすことしかチェックする

* 一般的な機能試験や業務シナリオが実現出来るかといったレベルのテストだとnスイッチ
    * 実行出来ないこと、起こらないこと、もテストする??
    * atomicity


実装に対するテスト
--------------------

### a. 0 スイッチカバレッジテスト

原則として以下を行った。

* 事前条件はなるべく網羅する
    * ガード条件が仮に```x = 1 /\  y \in {1,2}``` となっていたら、```(x,y)```として``` (1,1)``` と```(1,2)```を試す
    * 1つ注意点があって、実は「関係ない変数」は立派なガード条件になってると見做します(隠れガードって勝手に呼んでます）
    * 上の例の場合、変数がx,y,zの3種類在って、zの取りうる値の集合をZとすると、```x = 1 /\  y \in {1,2} /\ (z \in Z)``` とみなして、充足可能なパターンを試す
    * 実際にはそんなん網羅出来るハズもないので、ロジック的に関係ありそうな所を選んでお茶を濁す
* 事後状態の記述にIFがある場合、その分岐も網羅する

### b. n スイッチカバレッジテスト

業務シナリオをシナリオ法で書いて、出てきたフローをそのまま採用した。
後は、データのライフサイクルやら永続性やらといったタイムスパンに関するプロパティに着目して思いつく範囲でテストした。


### c. その他のテスト

* 探索的テスト(ランダムテストって呼んでたけど)
    * 主にモデルでは表現出来ない部分のテストを行う
    * ボタンではない場所をクリックしまくるとか、ボタン同時押しみたいに実際にはアトミックじゃないことを利用して遷移の隙間を狙うとか
    * 非機能要件の確認や、応答性を悪くするようないじめ方をやったり
* 負荷試験
    * 長時間試験や通信負荷試験



参考文献
------------

n スイッチカバレッジテストについては [高信頼化ソフトウェアのための開発手法ガイドブック](https://www.ipa.go.jp/files/000004550.pdf) を参照した。


